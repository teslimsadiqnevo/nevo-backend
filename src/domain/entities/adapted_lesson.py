"""Adapted lesson entity - Personalized content for students."""

from dataclasses import dataclass, field
from datetime import datetime
from typing import Any, Dict, List, Optional
from uuid import UUID, uuid4

from src.core.config.constants import AdaptedLessonStatus, ContentBlockType


@dataclass
class ContentBlock:
    """
    A single content block in an adapted lesson.

    Represents one unit of content (text, image, quiz, etc.)
    """

    type: ContentBlockType
    content: str
    id: UUID = field(default_factory=uuid4)
    order: int = 0

    # Type-specific fields
    emphasis: List[str] = field(default_factory=list)  # For text blocks
    ai_generated_url: Optional[str] = None  # For image blocks
    question: Optional[str] = None  # For quiz blocks
    options: List[str] = field(default_factory=list)  # For quiz blocks
    correct_index: Optional[int] = None  # For quiz blocks

    # Metadata
    metadata: Dict[str, Any] = field(default_factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        """Convert block to dictionary for JSON serialization."""
        result = {
            "id": str(self.id),
            "type": self.type.value,
            "content": self.content,
            "order": self.order,
        }

        if self.emphasis:
            result["emphasis"] = self.emphasis
        if self.ai_generated_url:
            result["ai_generated_url"] = self.ai_generated_url
        if self.question:
            result["question"] = self.question
        if self.options:
            result["options"] = self.options
        if self.correct_index is not None:
            result["correct_index"] = self.correct_index
        if self.metadata:
            result["metadata"] = self.metadata

        return result


@dataclass
class AdaptedLesson:
    """
    AdaptedLesson entity - A personalized version of a lesson for a specific student.

    Generated by AI based on student's NeuroProfile.
    """

    lesson_id: UUID
    student_id: UUID
    id: UUID = field(default_factory=uuid4)

    # Adaptation metadata
    adaptation_style: str = ""  # e.g., "Visual Focus, Simplified Text"
    lesson_title: str = ""

    # Content blocks
    content_blocks: List[ContentBlock] = field(default_factory=list)

    # Raw JSON storage (for flexibility)
    content_blocks_json: List[Dict[str, Any]] = field(default_factory=list)

    # Status
    status: AdaptedLessonStatus = AdaptedLessonStatus.PENDING
    is_active: bool = True

    # AI generation metadata
    ai_model_used: Optional[str] = None
    generation_prompt_hash: Optional[str] = None
    generation_duration_ms: Optional[int] = None

    # Timestamps
    created_at: datetime = field(default_factory=datetime.utcnow)
    updated_at: datetime = field(default_factory=datetime.utcnow)

    # Interaction stats
    view_count: int = 0
    completion_count: int = 0
    average_time_spent_seconds: int = 0

    def mark_as_generating(self) -> None:
        """Mark lesson as being generated."""
        self.status = AdaptedLessonStatus.GENERATING
        self.updated_at = datetime.utcnow()

    def mark_as_ready(self) -> None:
        """Mark lesson as ready for viewing."""
        self.status = AdaptedLessonStatus.READY
        self.updated_at = datetime.utcnow()

    def mark_as_failed(self) -> None:
        """Mark lesson generation as failed."""
        self.status = AdaptedLessonStatus.FAILED
        self.updated_at = datetime.utcnow()

    def set_content_blocks(self, blocks: List[Dict[str, Any]]) -> None:
        """Set content blocks from JSON data."""
        self.content_blocks_json = blocks
        self.content_blocks = [
            ContentBlock(
                type=ContentBlockType(block.get("type", "text")),
                content=block.get("content", ""),
                order=idx,
                emphasis=block.get("emphasis", []),
                ai_generated_url=block.get("ai_generated_url"),
                question=block.get("question"),
                options=block.get("options", []),
                correct_index=block.get("correct_index"),
                metadata=block.get("metadata", {}),
            )
            for idx, block in enumerate(blocks)
        ]
        self.updated_at = datetime.utcnow()

    def to_response_dict(self) -> Dict[str, Any]:
        """Convert to response format as specified in the API contract."""
        return {
            "lesson_title": self.lesson_title,
            "adaptation_style": self.adaptation_style,
            "blocks": [block.to_dict() for block in self.content_blocks],
        }

    def increment_view_count(self) -> None:
        """Increment view count."""
        self.view_count += 1

    def record_completion(self, time_spent_seconds: int) -> None:
        """Record a completion event."""
        self.completion_count += 1
        # Update rolling average
        total_time = self.average_time_spent_seconds * (self.completion_count - 1)
        self.average_time_spent_seconds = (total_time + time_spent_seconds) // self.completion_count
        self.updated_at = datetime.utcnow()
